import { PrismaClient } from '@prisma/client';
import { distance as levenshtein } from 'fastest-levenshtein';
import OpenAI from 'openai';
import * as dotenv from 'dotenv';
import { calculateEnhancedScore } from './candidate-scoring.service';
import { parseQuery, calculateContextBoost } from './query-parser.service';
import { predictChapters, calculateChapterBoost } from './chapter-predictor.service';

dotenv.config();

const prisma = new PrismaClient();
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

export interface Candidate {
  code: string;
  score: number;
  matchType: string;
  description?: string;
  source: 'fuzzy' | 'semantic' | 'combined';
}

/**
 * Calculate similarity score between two strings (0-1)
 * Uses Levenshtein distance normalized by length
 */
function calculateSimilarity(str1: string, str2: string): number {
  const longer = str1.length > str2.length ? str1 : str2;
  const shorter = str1.length > str2.length ? str2 : str1;

  if (longer.length === 0) return 1.0;

  const editDistance = levenshtein(longer.toLowerCase(), shorter.toLowerCase());
  return (longer.length - editDistance) / longer.length;
}

/**
 * Find best fuzzy matches for a query word against a list of target words
 */
function findBestFuzzyMatches(queryWord: string, targetWords: string[], threshold: number = 0.75): string[] {
  const matches: { word: string; score: number }[] = [];

  for (const target of targetWords) {
    const score = calculateSimilarity(queryWord, target);
    if (score >= threshold) {
      matches.push({ word: target, score });
    }
  }

  // Sort by score descending
  matches.sort((a, b) => b.score - a.score);

  return matches.slice(0, 5).map(m => m.word);
}

/**
 * Enhanced fuzzy keyword search returning TOP N candidates
 * @param query - User search query
 * @param limit - Maximum number of candidates to return (default: 50)
 * @returns Array of candidates sorted by score
 */
export async function fuzzyKeywordSearchMulti(query: string, limit: number = 50): Promise<Candidate[]> {
  const queryWords = query.toLowerCase().split(/\s+/).filter(w => w.length > 2);

  if (queryWords.length === 0) return [];

  try {
    // Get all HS codes with their searchable text
    const allCodes = await prisma.hsCode.findMany({
      select: {
        code: true,
        description: true,
        keywords: true,
        commonProducts: true,
        synonyms: true
      }
    });

    const results: { code: string; score: number; matchType: string; description: string }[] = [];

    for (const hsCode of allCodes) {
      let score = 0;
      let matchType = 'none';

      // Collect all searchable terms
      const searchTerms = [
        ...(hsCode.keywords || []),
        ...(hsCode.commonProducts || []),
        ...(hsCode.synonyms || []),
        ...hsCode.description.toLowerCase().split(/\s+/)
      ].filter(term => term.length > 2);

      // Check each query word against search terms
      for (const queryWord of queryWords) {
        // Exact match check (highest priority)
        const exactMatch = searchTerms.find(term =>
          term.toLowerCase() === queryWord.toLowerCase()
        );

        if (exactMatch) {
          score += 10;
          matchType = 'exact';
          continue;
        }

        // Partial match check
        const partialMatch = searchTerms.find(term =>
          term.toLowerCase().includes(queryWord.toLowerCase()) ||
          queryWord.toLowerCase().includes(term.toLowerCase())
        );

        if (partialMatch) {
          score += 5;
          if (matchType !== 'exact') matchType = 'partial';
          continue;
        }

        // Fuzzy match check (for typos)
        const fuzzyMatches = findBestFuzzyMatches(queryWord, searchTerms, 0.75);

        if (fuzzyMatches.length > 0) {
          score += 3;
          if (matchType === 'none') matchType = 'fuzzy';
        }
      }

      if (score > 0) {
        results.push({
          code: hsCode.code,
          score,
          matchType,
          description: hsCode.description
        });
      }
    }

    // Sort by score descending and return top N
    results.sort((a, b) => b.score - a.score);

    return results.slice(0, limit).map(r => ({
      code: r.code,
      score: r.score,
      matchType: r.matchType,
      description: r.description,
      source: 'fuzzy' as const
    }));

  } catch (error) {
    console.error('Fuzzy search error:', error);
    return [];
  }
}

/**
 * Semantic search returning TOP N candidates using vector similarity
 * ENHANCED with keyword matching, query context, and chapter prediction
 * @param query - User search query
 * @param limit - Maximum number of candidates to return (default: 50)
 * @returns Array of candidates sorted by enhanced score
 */
export async function semanticSearchMulti(query: string, limit: number = 50): Promise<Candidate[]> {
  try {
    // Generate embedding for query
    const response = await openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: query
    });

    const queryEmbedding = response.data[0]?.embedding;
    if (!queryEmbedding) return [];

    // Set HNSW ef_search parameter for accurate search
    // ef_search=40 provides good accuracy/performance balance for HNSW index
    // This searches the entire database accurately, unlike IVFFlat which only searches 1-3% by default
    await prisma.$executeRaw`SET LOCAL hnsw.ef_search = 40`;

    // Find most similar HS codes using cosine similarity
    // Get more results initially (limit * 2) so we can re-rank with enhanced scoring
    const results: any[] = await prisma.$queryRaw`
      SELECT
        code,
        description,
        keywords,
        common_products as "commonProducts",
        synonyms,
        1 - (embedding <=> ${JSON.stringify(queryEmbedding)}::vector) as similarity
      FROM hs_codes
      WHERE embedding IS NOT NULL
      ORDER BY embedding <=> ${JSON.stringify(queryEmbedding)}::vector
      LIMIT ${limit * 2}
    `;

    // Parse query for context-aware scoring
    const queryAnalysis = parseQuery(query);
    const predictedChapters = predictChapters(query);

    // Apply enhanced scoring to each candidate
    const enhancedResults = results.map(r => {
      const semanticScore = Number(r.similarity) * 10; // Base semantic score (0-10)

      // Apply keyword matching bonus (0-15 points)
      const keywordBonus = calculateEnhancedScore(
        query,
        {
          code: r.code,
          description: r.description,
          keywords: r.keywords,
          commonProducts: r.commonProducts,
          synonyms: r.synonyms
        },
        0 // We only want the bonus, not semantic score again
      );

      // Apply query context boost (0-10 points)
      const contextBoost = calculateContextBoost(
        {
          code: r.code,
          description: r.description,
          keywords: r.keywords,
          commonProducts: r.commonProducts
        },
        queryAnalysis
      );

      // Apply chapter prediction boost (0-5 points)
      const chapterBoost = calculateChapterBoost(r.code, predictedChapters);

      // Total enhanced score = semantic + keyword + context + chapter
      const totalScore = semanticScore + keywordBonus + contextBoost + chapterBoost;

      return {
        code: r.code,
        score: totalScore,
        matchType: 'semantic+keywords+context+chapter',
        description: r.description,
        source: 'semantic' as const
      };
    });

    // Sort by enhanced score and return top N
    enhancedResults.sort((a, b) => b.score - a.score);

    return enhancedResults.slice(0, limit);

  } catch (error) {
    console.error('Semantic search error:', error);
    return [];
  }
}

/**
 * Filter out noisy fuzzy matches that match only common words
 */
function filterNoisyFuzzyMatches(candidates: Candidate[], query: string): Candidate[] {
  // Common noise words that shouldn't match alone
  const commonWords = new Set(['pads', 'pad', 'for', 'the', 'and', 'with', 'other', 'parts']);

  // Extract meaningful query terms (2+ chars, not common words)
  const queryTerms = query.toLowerCase()
    .split(/\s+/)
    .filter(w => w.length > 2 && !commonWords.has(w));

  return candidates.filter(candidate => {
    // Keep candidates with score > 25 (likely good matches)
    if (candidate.score > 25) return true;

    // For lower scores, check if they match meaningful terms
    // or if it's just matching common noise words
    const description = (candidate.description || '').toLowerCase();

    // Count how many meaningful query terms appear in description
    const meaningfulMatches = queryTerms.filter(term => description.includes(term)).length;

    // Require at least 2 meaningful term matches for low-scoring fuzzy results
    // This filters out "shoulder pads", "mattress pads" when searching for "brake pads"
    return meaningfulMatches >= 2;
  });
}

/**
 * Combine and deduplicate candidates from multiple sources
 * IMPROVED: Prioritizes semantic search results and filters noisy fuzzy matches
 * @param fuzzyCandidates - Candidates from fuzzy search
 * @param semanticCandidates - Candidates from semantic search
 * @param limit - Maximum number of final candidates (default: 50)
 * @returns Deduplicated and ranked candidates
 */
export function combineCandidates(
  fuzzyCandidates: Candidate[],
  semanticCandidates: Candidate[],
  limit: number = 50
): Candidate[] {
  const candidateMap = new Map<string, Candidate>();

  // CRITICAL FIX: Filter out noisy fuzzy matches first
  // This prevents "shoulder pads", "mattress pads" from drowning out real results
  const filteredFuzzy = fuzzyCandidates.filter(c => {
    // Keep high-scoring fuzzy matches (>25)
    if (c.score > 25) return true;

    // For lower scores, only keep if code looks relevant (not random sports equipment, textiles, etc.)
    const code = c.code;
    const chapter = code.substring(0, 2);

    // Common automotive/industrial chapters
    const relevantChapters = ['87', '84', '68', '40', '73', '85', '86', '89'];

    // Keep if in relevant chapter OR high match type quality
    return relevantChapters.includes(chapter) || c.matchType === 'exact';
  });

  // PRIORITY 1: Add semantic candidates (these understand context better)
  // Weight semantic results heavily as they found 8708.30.00 at position 2
  for (const candidate of semanticCandidates) {
    candidateMap.set(candidate.code, {
      ...candidate,
      score: candidate.score * 1.5, // Boost semantic scores by 50%
      source: 'semantic'
    });
  }

  // PRIORITY 2: Merge filtered fuzzy candidates
  for (const candidate of filteredFuzzy) {
    const existing = candidateMap.get(candidate.code);

    if (existing) {
      // Code appears in both - combine scores
      // Give more weight to semantic (0.7) than fuzzy (0.3) since semantic understands context
      const semanticWeight = 0.7;
      const fuzzyWeight = 0.3;

      candidateMap.set(candidate.code, {
        code: candidate.code,
        score: existing.score * semanticWeight + candidate.score * fuzzyWeight,
        matchType: 'exact+semantic',
        description: existing.description || candidate.description,
        source: 'combined'
      });
    } else {
      // New candidate from fuzzy search only
      candidateMap.set(candidate.code, candidate);
    }
  }

  // Convert to array and sort by combined score WITH specificity bonus
  const combined = Array.from(candidateMap.values());

  // Sort by score first, then by code specificity (longer codes are more specific)
  combined.sort((a, b) => {
    const scoreDiff = b.score - a.score;

    // If scores are very close (within 0.5), prefer more specific codes
    if (Math.abs(scoreDiff) < 0.5) {
      // Count digits/specificity: remove dots and compare length
      const aSpecificity = a.code.replace(/\./g, '').length;
      const bSpecificity = b.code.replace(/\./g, '').length;
      return bSpecificity - aSpecificity;
    }

    return scoreDiff;
  });

  return combined.slice(0, limit);
}

/**
 * Main function: Get top N candidates from all search methods combined
 * @param query - User search query
 * @param limit - Maximum number of candidates to return (default: 50)
 * @returns Combined and deduplicated candidates
 */
export async function getTopCandidates(query: string, limit: number = 50): Promise<Candidate[]> {
  // CRITICAL DECISION: For multi-word queries (3+ words), rely primarily on semantic search
  // Fuzzy search creates too much noise for specific product queries like "ceramic brake pads for motorcycles"
  const queryWords = query.trim().split(/\s+/);

  if (queryWords.length >= 3) {
    // Multi-word query: Use semantic search ONLY
    // Semantic search with HNSW index understands context and finds the right codes
    // This ensures 8708.30.00 appears at position 2 instead of being drowned out by noise
    const semanticCandidates = await semanticSearchMulti(query, limit);
    return semanticCandidates;
  }

  // For short queries (1-2 words), use combined approach
  const [fuzzyCandidates, semanticCandidates] = await Promise.all([
    fuzzyKeywordSearchMulti(query, limit),
    semanticSearchMulti(query, limit)
  ]);

  // Combine and deduplicate
  const finalCandidates = combineCandidates(fuzzyCandidates, semanticCandidates, limit);

  return finalCandidates;
}

/**
 * Get detailed candidate information including metadata
 * @param codes - Array of HS codes to fetch details for
 * @returns Array of detailed candidate information
 */
export async function getCandidateDetails(codes: string[]): Promise<any[]> {
  try {
    const details = await prisma.hsCode.findMany({
      where: {
        code: { in: codes }
      },
      select: {
        code: true,
        description: true,
        keywords: true,
        commonProducts: true,
        synonyms: true,
        notes: true
      }
    });

    return details;
  } catch (error) {
    console.error('Error fetching candidate details:', error);
    return [];
  }
}
